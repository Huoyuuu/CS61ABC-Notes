# AList

## AList介绍

### 来源

DLList使用get方法时速度较慢，即使只是查询一个第k位的元素，也要遍历k个位置，极端情况下甚至要遍历整个链表，性能开销很大。Array支持O(1)时间查询，考虑用数组实现链表。

练习（假定加入元素不超过100个）：

1. addLast()
2. getLast()
3. get()
4. size()

### 扩容和收缩操作

当数组元素存满的时候，再使用addLast()就没有地方可以放入数据了，需要扩容。申请一片新空间，然后把原数组整体迁移过去。（指数级别扩容，保证分摊复杂度为O(1)）

```java
int[] a = new int[size * 2];
System.arraycopy(items, 0, a, 0, size);
a[size] = 11;
items = a;
size = size + 1;
```

当数组元素较少的时候，显然会有很多的空间冗余，可以考虑数组收缩。申请一片新空间，然后把原数组整体迁移过去。

```java
int[] a = new int[size / 2];
System.arraycopy(items, 0, a, 0, size);
a[size] = 11;
items = a;
size = size + 1;
```

为了防止频繁扩容和频繁收缩，一般保证空间利用率在25%~100%之间即可。低于25%收缩，等于100%扩容。

### 泛型对象数组

由于Java不允许创建泛型对象数组，也就是不允许如下操作：

```java
Glorp[] items = new Glorp[8];
```

实际应用中，我们使用如下操作：

```java
Glorp[] items = (Glorp []) new Object[8];
```

为什么？<https://www.tothenew.com/blog/why-is-generic-array-creation-not-allowed-in-java/>
假设允许创建泛型数组，数组可以由子类数组转换为父类数组、泛型对象却不能，因此当数组转换类型后可以对不同元素赋不同类型的值，但泛型对象不能切换类型，不能接受赋值，此时去调用泛型对象就会出错。

此外，Java的GC系统只会回收没有索引的元素，因此当我们把元素从AList中删除的时候，需要把对应处置为null。

## 章末小结

### 我学到了什么？

- 为降低get()的时间复杂度，使用数组实现链表。
- 数组扩容时以指数级别进行扩容，保证均摊复杂度为O(1)。
- 链表中删除元素时需要将元素置为null。
- Java不允许创建泛型数组

### 如何学会的？

- 不理解的时候尝试把零碎的知识点写下来，然后自己组织语句去把它解释明白。整个过程有些类似计算理论中“有限状态自动机”与“图灵机”之间的区别，图灵机之所以比有限状态自动机强大，就在于它可以把内容先写下来。那么对应的，如果只看不写，就只有类似FA的能力，但如果既看又写，就可以复刻图灵机的超凡力量。

### 怎么类推出去？

- 觉得无从下手时，把零碎的内容写下来，然后组织语句把他们联系起来，有可能的话尝试自己给自己讲明白、自己给别人讲明白。
