# 处理碰撞

## 引入

### 现状

1. 新建长度为N的ArrayList。
2. 增加元素，获取元素的hashcode，然后模N得到应存放的位置k。
3. 如果k位置没有元素，将当前元素放入即可，如果k位置有元素且不等于当前元素，此时发生碰撞。
4. 删除元素，同理找到位置k，删掉k位置的元素即可。
5. 查找元素，同理找到位置k，判断k位置是否有元素即可。

### 问题

由上述内容可知，如果不发生碰撞则我们的散列表已经接近完成，当前关键就在于处理碰撞问题。

### 拉链法存储元素

为此，我们可以把ArrayList的每一位都新建为一个链表，对每个应放在k处的元素，都把它放到k处的链表中，保证即使hashcode碰撞也能通过检查链表获取确定元素。

查阅资料可知，JDK中处理碰撞问题采用的就是拉链法，但从Java8开始改用平衡树。

### 其他方法

- 开放寻址法，发生冲突时，把当前元素映射到另一处空间内，如此反复直到最终存放到散列表内。（要求散列表中仍有剩余空间）
- 使用新的哈希函数再次计算哈希值。
- 缓存思想。建立公共溢出区，把碰撞的元素存放到公共溢出区内。
