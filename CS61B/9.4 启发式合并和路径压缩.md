# 启发式合并 和 路径压缩

## 引入

由上一节可知关键在于优化find()。观察find()可知，每次调用find()函数，都需要爬到树的根部，因此树越短find()越快！

具体操作：每次合并时，把高度较低的树合并到高度较高的树上。保证整体高度不变或至多增加1，进一步分析可知：启发式合并得到的树最大高度为$\Omicron(log(N))$。

实际上，不只合并的时候可以优化树高，find()方法本身也可以优化树的高度。在find()结束后，让当前节点之间指向根节点，即可实现路径压缩，可以进一步优化树的高度，甚至保证树高为1。

### 具体实现

- 使用两个数组，一个记录父节点，另一个记录自己为根节点的子树权重。每次合并时考虑两棵树的高度，优先把高度低的树合并到高度高的树上去。
- find()结束后，让当前节点直接指向根节点。

### 代码实现

> 参考Lab6
