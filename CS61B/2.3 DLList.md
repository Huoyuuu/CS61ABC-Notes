# 双链表DLList

## 设计DLList

### 怎样把元素加到末尾去，设计addLast()

回顾SLList中设计的addLast()方法，我们先把链表从头遍历到尾，然后在末尾添加一个新元素，只是增加了一个元素，却需要遍历整个链表，时间开销太大。

那么，有没有简单的办法呢？考虑缓存的思想，添加一个指向链表尾部的指针last，每次增加元素直接通过指针去添加即可。

### 怎样移除末尾的元素，设计removeLast()

那么怎么移除末尾的元素呢？我们确实有指向末尾的指针last，删掉last指向的节点即可，但是last本身不能找到新链表的末尾，设立新的last又需要再次遍历整个链表。于是只删除了一个元素，却需要遍历整个链表。

那么，有没有简单的方法呢？考虑不变量的思想，我们只需要能让last找到上一个节点即可，因此为每个节点添加一个指向上一个节点的指针，last删除当前节点并前移到上一个节点处即可。

### 双向循环链表

改动之后我们回顾一下整个链表。我们有头部的哨兵节点sentinel，有指向尾部的指针last，链表中每个节点都有两个指针分别指向前后节点。

宏观考虑一下整个链表的结构，我们不妨让sentinel的另一个指针去实现last的功能，让sentinel和尾部节点连接起来，这样就是双向循环链表。显然，从统一的角度来说，双向循环链表要更优一些。

### 泛型

到此为止，我们的链表只能处理int类型的元素，为了能方便地推广到其他类型元素上去，Java提供了一种叫“泛化”的语法。

```java
public class Test<T> {
    private IntNode sentinel;
    private int size;

    public class IntNode {
        public IntNode prev;
        public T item;
        public IntNode next;
        ...
    }
    ...
}
```

调用时只需

```java
DLList<String> d1 = new DLList<>("Hello ");
d1.insertFront("World!");
```

> 注意原始类型byte、short、int、long、float、double、char和boolean不能简单的套用上去，要用对应的封装类型，Byte、Short、Integer、Long、Float、Double、Character和Boolean。

## 章末小结

### 我学到了什么？

- 为了处理尾部的增删操作，每个节点对应存储指向前一节点的指针，由此引入双向链表及进一步的双向循环链表。
- Java泛型可以很容易地把只能处理一种类型的类拓展为可以处理多个类型的类。
- 泛型不支持八种原始类型，要用对应的八种封装类型。

### 如何学会的？

- 在实践中去尝试解决同样的问题，尝试提出合适的解决方案，思考后和学到的内容对比印证。

### 怎么类推出去？

- 问题和功能相对应，功能和结构相联系。新结构不容易理解的话，一层层回溯上去，试着自己去解决最初的问题，有思考有实践，进而有助于深层的理解。
