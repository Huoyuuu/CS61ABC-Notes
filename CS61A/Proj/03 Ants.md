
- [Ants](#ants)
  - [概述](#概述)
  - [文件](#文件)
  - [具体实现](#具体实现)
    - [核心类](#核心类)
    - [具体蜜蜂](#具体蜜蜂)
      - [Container Add的实现：](#container-add的实现)
      - [QueenAnt 的实现](#queenant-的实现)
      - [SlowThrower 的实现](#slowthrower-的实现)
      - [ScaryThrower 的实现](#scarythrower-的实现)
      - [NinjaAnt 和 ScubaThrower 的实现：](#ninjaant-和-scubathrower-的实现)
  - [总结](#总结)
    - [项目总结](#项目总结)
      - [让对方自己解决问题](#让对方自己解决问题)
    - [我学到了什么](#我学到了什么)


# [Ants](https://inst.eecs.berkeley.edu/~cs61a/su20/proj/ants/)

## 概述

塔防游戏，蚂蚁VS蜜蜂。

- 蚁穴。主题地图。
- 蜂巢。蜜蜂出现的位置。
- 地点。蚂蚁和蜜蜂发生争夺的位置。
- 蚂蚁。己方势力，分为获取食物的蚂蚁和负责进攻的蚂蚁。
- 蜜蜂。地方势力，从蜂巢产生，进入蚁穴时游戏失败。

## 文件

- ants.py: 主体逻辑
- ants_gui.py: GUI文件
- graphics.py: 展示二维动画的功能文件
- utils.py: 用于简化游戏界面的函数
- ucb.py: CS61A的功能文件
- assets: GUI界面的图片和文件
- img: GUI界面用到的图片
- ok: ok评测系统
- proj3.ok: ok评测系统的配置文件
- tests: 测试文件夹

## 具体实现

### 核心类
- GameState: 表示蚁穴和总体状况的类。比如食物、游戏时间、蚁后位置和所有地点等。
- Place: 容纳昆虫的单个地点。每个地点只能容纳一只蚂蚁，但可以包含多个蜜蜂。每个蜜蜂自右侧进入，从左侧离开。
- Hive: 表示蜜蜂的起始位置（在地图右侧）
- AntHomeBase: 表示蚂蚁防守位置，如果蜜蜂到达这里，蚂蚁失败。
- Insect: 蚂蚁和蜜蜂的超类。armor表示剩余血量，place表示当前位置，每回合活跃的昆虫执行对应行动。
- Ant: 蚂蚁类。子类中具有不同的属性，比如收割蚂蚁获取食物，投掷蚂蚁攻击蜜蜂。每只蚂蚁还有food_cost属性表示消耗多少食物。
- Bee: 表示蜜蜂。如果下一个地点没有蚂蚁，蜜蜂将向前移动，否则蜜蜂将蛰刺蚂蚁。

### 具体蜜蜂

#### Container Add的实现：
1. 恰有一个是container
2. 添加后Place.ant = container
3. contain的action调用自己和子类的action

#### QueenAnt 的实现
1. 将后面的每只蚂蚁damage翻倍，已翻倍的不做处理
2. 蚁后死掉，游戏失败
3. 只能有一只蚁后
4. 蚁后不能被手动移除

#### SlowThrower 的实现
1. 给蜜蜂施加3回合的缓慢状态。
2. 蜜蜂缓慢状态下只能在gamestate.time为偶数时移动，奇数时不能做任何事情。
3. 如果蜜蜂又被施加缓慢，缓慢状态+3回合。

#### ScaryThrower 的实现
1. 给蜜蜂施加2回合的scared状态
2. 让蜜蜂后退而不是前进。蜜蜂保持scared状态直到尝试移动两次。
3. 同一只蜜蜂不能被再次scared。

> 状态叠加：蜜蜂有slow状态，且gamestate.time为奇数时，不认为能被scared。

#### NinjaAnt 和 ScubaThrower 的实现：
1. 新增状态检验时，在基类中添加新状态，添加默认值
2. 子类继承新状态，并做特定修改

## 总结

### 项目总结

预计是为期7天的项目。有一定的难度，但是提供的框架、文档和测试样例，足以把难度降低许多许多。实际完成时按部就班做就好。

#### 让对方自己解决问题

项目中很多次用到判定是否是xxx的功能，或者对对方造成xxx伤害的功能。比如判定一只Ant是否是Container类型最开始自己摸不着头脑，难道要凭借名字去判定？那也太麻烦了。

写着写着才发现，让它自己说出来就好了。形象一点是这样的：
```
我：Ant, Ant, 你是Container类型吗？
Ant: 是的，是的，我是Container类型。
```

这样的例子很多，比如判定是否是蜂巢的is_hive，比如判定是否是container的is_container，比如是否会阻塞道路的blocks_path等等。

不仅状态可以让对方自己解决，具体操作也可以让对方自己处理。比如造成伤害，并非是Ant对Bee或者Bee对Ant直接进行怎样的操作，而是调用对方自身的减伤函数。把问题交给对方自己解决，相当于现实中一个人既充分说明自己的优点，也完全展示自己的缺点，现实中几乎不会这么坦诚，但OOP底层逻辑就是这样直白，就是这样君子协议。Bee不会一上来就秒掉Ant，Ant也不会一上来秒掉Bee，双方都在规则范围内进行具体行为操作。玩味起来也很是有趣。

### 我学到了什么

1. 面向对象的核心，构造统一基类，各自继承并重写方法。
2. 添加新特性的子类时，不在子类中做修改，而是到基类去，在基类中添加新状态和默认值，然后子类继承并重写。（Ninja不阻塞道路 + ScubaThrower可放置在水上）
3. 说清楚输入输出、各功能实现顺序的说明文档，和细致的测试样例，实在是降低项目难度的大好帮手。
4. 游戏是Ants VS Bees，但是实际写的时候，并不是Ants对Bees施加伤害，也不是Bees对Ants施加伤害，而是去调用对方自己的减伤函数，颇为有趣。**如果对方能自己解决问题，就不要越俎代庖。**
