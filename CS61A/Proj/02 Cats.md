- [Cats](#cats)
  - [概述](#概述)
  - [文件](#文件)
  - [具体实现](#具体实现)
    - [测速功能](#测速功能)
    - [自动更正功能](#自动更正功能)
    - [联机对战功能](#联机对战功能)
    - [附加项](#附加项)
  - [总结](#总结)
    - [项目总结](#项目总结)
      - [第一个是移位变换函数和操作变化函数的写法。](#第一个是移位变换函数和操作变化函数的写法)
      - [第二个是EC2的记忆化操作](#第二个是ec2的记忆化操作)
    - [我学到了什么](#我学到了什么)

# [Cats](https://inst.eecs.berkeley.edu/~cs61a/su20/proj/cats/)

## 概述

本质上是打字软件，单机版本提供测速 + 自动更正功能，联机版本提供联机对战功能。

## 文件
- cats.py: 主体逻辑
- utils.py: 操作文件和字符串的功能函数
- ucb.py: 61A项目的功能函数
- data/sample_paragraphs.txt: 文本示例，内容来自维基百科的不同主题
- data/common_words.txt: 单词示例，按频率排序
- data/words.txt: 更多的单词示例，按频率排序
- gui.py: 基于web server实现的GUI界面
- gui_files: GUI配套文件
- images: 相关图片
- ok: ok评测系统
- tests: 评测文件

## 具体实现
### 测速功能

计算打字进度
给定typed和reference文本，返回对应位置，typed中正确单词的百分比。
如果typed有多余单词，那么多余单词都不正确。
如果typed为空，那么返回0。

计算wpm（words per minute）
实际上是按字母算的word，取平均长度5算wpm。

### 自动更正功能

选择应当更正的单词
1. 如果单词在列表中，直接返回。
2. 如果不在，返回差距最小的单词。（差距根据提供的差距函数计算得到）
3. 如果有多个单词差距最小，那么返回第一个出现的单词。

移位变换函数，逐位比对计算两单词之间的差距。(要求使用递归完成)
1. 判定是否存在空串，如果有返回另一个串的长度。
2. 判定首字母是否相等，如果相等递归处理。
3. 判定limit是否为0，如果为0返回1。
4. 此时首字母必然不等，递归处理[1:]字符串，并将递归函数中的limit减1。

操作变化函数，给定加字母、减字母和改字母三种操作，计算两单词之间的差距。

### 联机对战功能

向服务器发送进度字典形式的数据{id: 用户ID, accuracy: 正确率}

给定单词和玩家完成单词的时间戳，输出玩家每个单词所用时间。

找出每个人输入最快的单词，以列表形式输出。[['What', 'luck'], ['great']]
反过来，对每个单词，找是谁输入的最快即可。

### 附加项

1. 考虑用户输入设备。单词输入是基于QWERTY键盘实现的，在键盘上wird可能是wire也可能是bird，但是显然更可能是wire。
据此实现更精确地操作变化函数。
2. 考虑服务器存储设备。通过记忆化提高比对速度。
```python
    if (user_word, diff_function, limit) in cache:
        return cache[(user_word, diff_function, limit)]
    ...
    cache[(user_word, diff_function, limit)] = valid_words[min_index]
```

## 总结

### 项目总结

CS61A的第二个项目，难度和复杂度都并不是很大。
按部就班去实现即可。

值得一提的有两个地方，

#### 第一个是移位变换函数和操作变化函数的写法。
做Problem 6的时候觉得莫名其妙，一个for循环就能轻松解决的问题，要用递归去做。做完Problem 7拍案叫绝，两个函数的功能相去甚远，但是递归写起来竟能如此相似。函数本身没什么神奇的，神奇的是从递归的角度看，两函数功能不同但实现逻辑却完全一致，有一种有限状态自动机的感觉。

想来也是，递归问题只需考虑当前层的解法，有限自动机中每个计算单元只需考虑自己的处理结果，考虑范围缩小了，解决起来就容易了，彼此相似也很合理。

那么更进一步地，递归问题没有思路时，可以从有限状态自动机入手，分解状态，然后尝试把状态和递归关系映射起来，也许是一个解决思路。

#### 第二个是EC2的记忆化操作
1. 如果word在valid_words中，那么直接返回。
2. 如果(word, function, limit)在cache中，那么返回cache数据。
3. 否则正常计算，并将结果保存在cache中。

用Python去做的时候，发现list不支持hash操作，当时这里折腾了好久，比对时候list是共用的，自己写一个剔除list的Cache就行了嘛。

### 我学到了什么

1. Python的推导式非常方便，列表方面可以多用，注意和zip/enumerate等结合起来使用，效果更佳。
2. 61A的unlock部分，有时候计算量过大，可以先把函数实现出来，直接在终端中运行结果，可以提高效率。unlock本身也是辅助理解题意才实现的，既然已经把问题解决掉了，就不必拘泥形式去手算题目了。
3. 递归思路和有限状态自动机有相似之处，递归做不出来，可以考虑从有限状态自动机入手，分析状态，然后尝试把状态和递归关系对应起来。